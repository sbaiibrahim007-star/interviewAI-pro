import React, { useEffect, useMemo, useRef, useState } from "react";

// --- Utilitaires ---
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

const FR_QUESTIONS_BASE = [
  "Parlez-moi de vous.",
  "Pourquoi voulez-vous ce poste ?",
  "Quelles sont vos plus grandes forces ?",
  "Citez une faiblesse et comment vous la gérez.",
  "Racontez une situation où vous avez résolu un problème difficile.",
  "Comment gérez-vous la pression et les deadlines ?",
  "Parlez d’un échec et de ce que vous avez appris.",
  "Où vous voyez-vous dans 3 ans ?",
  "Pourquoi devrions-nous vous embaucher ?",
  "Avez-vous des questions pour nous ?",
];

const THEME_QUESTIONS = {
  general: FR_QUESTIONS_BASE,
  developpeur: [
    "Parlez d’un projet récent : votre rôle et les résultats ?",
    "Comment assurez-vous la qualité de votre code ?",
    "Décrivez un bug complexe que vous avez corrigé.",
    "Comment priorisez-vous tâches et dette technique ?",
    "Quelles technologies vous maîtrisez le mieux et pourquoi ?",
  ],
  commercial: [
    "Décrivez votre process de prospection.",
    "Parlez d’un deal difficile que vous avez gagné.",
    "Comment traitez-vous les objections ?",
    "Quels KPI suivez-vous au quotidien ?",
    "Votre stratégie pour fidéliser un client clé ?",
  ],
  support: [
    "Racontez une situation client tendue que vous avez désamorcée.",
    "Comment priorisez-vous les tickets ?",
    "Quels outils ITSM avez-vous utilisés ?",
    "Comment documentez-vous les incidents ?",
    "Qu’attendez-vous d’une équipe N2/N3 ?",
  ],
};

// Scoreur très simple : longueur, structure, mots clés, tics de langage
function scoreAnswer(answer) {
  if (!answer) return { score: 0, feedback: "Réponse vide. Essayez de développer." };
  const text = answer.toLowerCase();
  const words = text.split(/\s+/).filter(Boolean);
  const len = words.length;
  const fillers = (text.match(/euh|heu|genre|tu vois|en mode|bref/g) || []).length;
  const structureHints = ["situation", "tâche", "action", "résultat", "star", "exemple", "impact"];
  const structureHits = structureHints.reduce((acc, k) => acc + (text.includes(k) ? 1 : 0), 0);
  const keywordHints = ["objectif", "mesurable", "amélioré", "réduit", "augmenté", "livré", "qualité", "performance"];
  const keywordHits = keywordHints.reduce((acc, k) => acc + (text.includes(k) ? 1 : 0), 0);

  // scoring naïf
  let score = 0;
  score += Math.min(40, Math.max(0, (len - 25))); // +1 pt par mot au-delà de 25, cap 40
  score += structureHits * 10; // max 70 si tous présents (irréaliste)
  score += keywordHits * 6; // max ~42
  score -= Math.min(20, fillers * 4);
  score = Math.max(0, Math.min(100, score));

  const tips = [];
  if (len < 60) tips.push("Développez davantage : visez 60–120 mots.");
  if (fillers > 0) tips.push("Réduisez les tics de langage (euh, genre…).");
  if (structureHits < 2) tips.push("Structurez en STAR (Situation, Tâche, Action, Résultat).");
  if (keywordHits < 2) tips.push("Ajoutez des mots orientés impact (augmenté, réduit, livré).");

  return {
    score: Math.round(score),
    feedback: tips.length ? tips.join(" ") : "Solide ! Continuez comme ça.",
  };
}

// Avatar SVG minimal avec animation de bouche
function TalkingAvatar({ speaking }) {
  return (
    <div className="w-40 h-40 mx-auto">
      <svg viewBox="0 0 200 200" className="w-full h-full">
        <defs>
          <linearGradient id="skin" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stopColor="#f6d2b8" />
            <stop offset="100%" stopColor="#e8b89a" />
          </linearGradient>
        </defs>
        <circle cx="100" cy="100" r="90" fill="url(#skin)" />
        <circle cx="70" cy="90" r="8" fill="#222" />
        <circle cx="130" cy="90" r="8" fill="#222" />
        {/* bouche */}
        <g>
          <ellipse
            cx="100"
            cy={speaking ? 125 : 128}
            rx={speaking ? 18 : 12}
            ry={speaking ? 12 : 4}
            fill="#7a2d2d"
          />
        </g>
      </svg>
    </div>
  );
}

// Détection des API Web
function getSpeechRecognition() {
  const w = window;
  return (
    w.SpeechRecognition ||
    w.webkitSpeechRecognition ||
    w.mozSpeechRecognition ||
    w.msSpeechRecognition ||
    null
  );
}

function listVoices(langStartsWith = "fr") {
  const all = window.speechSynthesis?.getVoices?.() || [];
  return all.filter((v) => v.lang && v.lang.toLowerCase().startsWith(langStartsWith));
}

export default function App() {
  const [theme, setTheme] = useState("general");
  const [jobTitle, setJobTitle] = useState("");
  const [sessionActive, setSessionActive] = useState(false);
  const [questionIndex, setQuestionIndex] = useState(0);
  const [speaking, setSpeaking] = useState(false);
  const [recognizing, setRecognizing] = useState(false);
  const [answer, setAnswer] = useState("");
  const [log, setLog] = useState([]); // {q, a, score, feedback}
  const [autoContinue, setAutoContinue] = useState(true);
  const [useMic, setUseMic] = useState(true);
  const [voiceName, setVoiceName] = useState("");

  const Recognition = useMemo(() => getSpeechRecognition(), []);
  const recogRef = useRef(null);
  const abortRef = useRef(false);

  const questions = useMemo(() => {
    const base = THEME_QUESTIONS[theme] || FR_QUESTIONS_BASE;
    if (!jobTitle) return base;
    // Injecte une question orientée poste en tête
    const injected = [`Qu’est-ce qui vous attire spécifiquement dans le poste de ${jobTitle} ?`, ...base];
    return injected;
  }, [theme, jobTitle]);

  // Charge voix
  const [voices, setVoices] = useState([]);
  useEffect(() => {
    const load = () => setVoices(listVoices("fr"));
    load();
    if (window.speechSynthesis) {
      window.speechSynthesis.onvoiceschanged = load;
    }
  }, []);

  useEffect(() => {
    if (!voiceName && voices.length) {
      setVoiceName(voices[0].name);
    }
  }, [voices, voiceName]);

  const currentQuestion = questions[questionIndex] || "C’est terminé !";

  async function speak(text) {
    if (!window.speechSynthesis) return;
    const u = new SpeechSynthesisUtterance(text);
    const v = voices.find((vv) => vv.name === voiceName);
    if (v) u.voice = v;
    u.lang = v?.lang || "fr-FR";
    u.onstart = () => setSpeaking(true);
    u.onend = () => setSpeaking(false);
    window.speechSynthesis.speak(u);
    // Attend la fin de la parole (approx)
    while (window.speechSynthesis.speaking) {
      await sleep(120);
      if (abortRef.current) {
        window.speechSynthesis.cancel();
        break;
      }
    }
  }

  function startRecognition() {
    if (!Recognition || !useMic) return; // fallback mode: saisie texte
    const rec = new Recognition();
    rec.lang = "fr-FR";
    rec.interimResults = false;
    rec.maxAlternatives = 1;

    rec.onstart = () => setRecognizing(true);
    rec.onresult = (e) => {
      const transcript = Array.from(e.results)
        .map((r) => r[0].transcript)
        .join(" ");
      setAnswer(transcript);
      setRecognizing(false);
    };
    rec.onerror = () => setRecognizing(false);
    rec.onend = () => setRecognizing(false);
    rec.start();
    recogRef.current = rec;
  }

  function stopRecognition() {
    try {
      recogRef.current?.stop?.();
    } catch {}
    setRecognizing(false);
  }

  async function askNextQuestion() {
    abortRef.current = false;
    setAnswer("");
    const q = questions[questionIndex];
    if (!q) return;
    await speak(q);
    if (useMic && Recognition) startRecognition();
  }

  async function startSession() {
    setSessionActive(true);
    setQuestionIndex(0);
    setLog([]);
    await sleep(200);
    askNextQuestion();
  }

  function stopSession() {
    abortRef.current = true;
    window.speechSynthesis?.cancel?.();
    stopRecognition();
    setSessionActive(false);
  }

  async function submitAnswer() {
    stopRecognition();
    const q = questions[questionIndex];
    const { score, feedback } = scoreAnswer(answer);
    const entry = { q, a: answer, score, feedback };
    setLog((prev) => [...prev, entry]);
    // Feedback vocal bref
    await speak(`Score ${score} sur 100. ${feedback}`);

    const next = questionIndex + 1;
    setQuestionIndex(next);
    if (autoContinue && next < questions.length) {
      await sleep(400);
      askNextQuestion();
    }
  }

  function exportJSON() {
    const payload = {
      createdAt: new Date().toISOString(),
      theme,
      jobTitle,
      transcript: log,
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `simulation-entretien-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  return (
    <div className="min-h-screen bg-gray-50 text-gray-900 p-6">
      <div className="max-w-4xl mx-auto space-y-6">
        <header className="flex items-center justify-between">
          <h1 className="text-2xl font-bold">Simulateur d’entretien IA – Avatar & Voix (local, illimité)</h1>
          <div className="text-xs opacity-70">Aucune donnée ne quitte votre navigateur.</div>
        </header>

        <div className="grid md:grid-cols-3 gap-4">
          <div className="md:col-span-2 bg-white rounded-2xl shadow p-4 space-y-4">
            <div className="flex items-center gap-4">
              <TalkingAvatar speaking={speaking} />
              <div className="flex-1 space-y-2">
                <div className="text-sm">Avatar IA</div>
                <div className="text-lg font-semibold">{currentQuestion}</div>
                <div className="text-xs text-gray-500">
                  {recognizing ? "Écoute en cours… parlez." : sessionActive ? "Répondez puis validez." : "Cliquez sur Démarrer."}
                </div>
              </div>
            </div>

            <div className="space-y-2">
              <label className="text-sm font-medium">Votre réponse</label>
              <textarea
                className="w-full min-h-[120px] p-3 rounded-xl border focus:outline-none focus:ring"
                placeholder={useMic && Recognition ? "Parlez (reconnaissance vocale) ou tapez ici…" : "Tapez votre réponse ici…"}
                value={answer}
                onChange={(e) => setAnswer(e.target.value)}
              />
              <div className="flex gap-2">
                {Recognition && (
                  <button
                    onClick={() => (recognizing ? stopRecognition() : startRecognition())}
                    className={`px-3 py-2 rounded-xl border ${
                      recognizing ? "bg-red-50 border-red-300" : "bg-gray-50"
                    }`}
                    disabled={!sessionActive}
                  >
                    {recognizing ? "Arrêter le micro" : "Activer le micro"}
                  </button>
                )}
                <button
                  onClick={submitAnswer}
                  className="px-4 py-2 rounded-xl bg-black text-white shadow"
                  disabled={!sessionActive || !currentQuestion || !answer.trim()}
                >
                  Valider la réponse
                </button>
              </div>
            </div>
          </div>

          <aside className="bg-white rounded-2xl shadow p-4 space-y-4">
            <div className="space-y-2">
              <label className="text-sm font-medium">Thème</label>
              <select
                className="w-full p-2 rounded-xl border"
                value={theme}
                onChange={(e) => setTheme(e.target.value)}
                disabled={sessionActive}
              >
                <option value="general">Général</option>
                <option value="developpeur">Développeur</option>
                <option value="commercial">Commercial</option>
                <option value="support">Support / Helpdesk</option>
              </select>
            </div>

            <div className="space-y-2">
              <label className="text-sm font-medium">Intitulé du poste (optionnel)</label>
              <input
                className="w-full p-2 rounded-xl border"
                placeholder="ex: Technicien IT, Data Analyst…"
                value={jobTitle}
                onChange={(e) => setJobTitle(e.target.value)}
                disabled={sessionActive}
              />
            </div>

            <div className="space-y-2">
              <label className="text-sm font-medium">Voix de l’avatar</label>
              <select
                className="w-full p-2 rounded-xl border"
                value={voiceName}
                onChange={(e) => setVoiceName(e.target.value)}
                disabled={sessionActive && speaking}
              >
                {voices.length ? (
                  voices.map((v) => (
                    <option key={v.name} value={v.name}>{v.name} ({v.lang})</option>
                  ))
                ) : (
                  <option value="">Voix système indisponibles</option>
                )}
              </select>
              <div className="text-xs text-gray-500">Les voix dépendent de votre navigateur/OS. Idéal : Chrome en fr-FR.</div>
            </div>

            <div className="flex items-center gap-2">
              <input id="mic" type="checkbox" className="scale-110" checked={useMic} onChange={(e) => setUseMic(e.target.checked)} disabled={sessionActive && recognizing} />
              <label htmlFor="mic" className="text-sm">Utiliser le micro (reconnaissance vocale)</label>
            </div>
            <div className="flex items-center gap-2">
              <input id="auto" type="checkbox" className="scale-110" checked={autoContinue} onChange={(e) => setAutoContinue(e.target.checked)} />
              <label htmlFor="auto" className="text-sm">Enchaîner automatiquement les questions</label>
            </div>

            <div className="flex gap-2 pt-2">
              {!sessionActive ? (
                <button onClick={startSession} className="flex-1 px-4 py-2 rounded-xl bg-emerald-600 text-white shadow">Démarrer</button>
              ) : (
                <button onClick={stopSession} className="flex-1 px-4 py-2 rounded-xl bg-rose-600 text-white shadow">Arrêter</button>
              )}
              <button onClick={askNextQuestion} className="px-4 py-2 rounded-xl border" disabled={!sessionActive}>Répéter la question</button>
            </div>

            <div className="pt-2">
              <button onClick={exportJSON} className="w-full px-4 py-2 rounded-xl border">Exporter le compte rendu (JSON)</button>
            </div>
          </aside>
        </div>

        <section className="bg-white rounded-2xl shadow p-4">
          <h2 className="font-semibold mb-3">Historique & feedback</h2>
          {log.length === 0 ? (
            <div className="text-sm text-gray-500">Vos réponses et scores apparaîtront ici.</div>
          ) : (
            <div className="space-y-3">
              {log.map((item, idx) => (
                <div key={idx} className="rounded-xl border p-3">
                  <div className="text-sm font-medium">Q{idx + 1}. {item.q}</div>
                  <div className="mt-1 whitespace-pre-wrap text-sm">{item.a}</div>
                  <div className="mt-2 text-sm"><span className="font-semibold">Score :</span> {item.score}/100</div>
                  <div className="text-xs text-gray-600">{item.feedback}</div>
                </div>
              ))}
            </div>
          )}
        </section>

        <footer className="text-xs text-gray-500 text-center">
          Astuce : structurez vos réponses en <b>STAR</b> (Situation, Tâche, Action, Résultat) et ciblez l’<b>impact</b> avec des chiffres.
        </footer>
      </div>
    </div>
  );
}
